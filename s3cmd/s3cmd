#!/usr/bin/env python2.5

## Amazon S3 manager
## Author: Michal Ludvig <michal@logix.cz>
##         http://www.logix.cz/michal
## License: GPL Version 2

import sys
import logging
import time
import os
import re
import errno
import pwd, grp

from copy import copy
from optparse import OptionParser, Option, OptionValueError, IndentedHelpFormatter
from logging import debug, info, warning, error
from distutils.spawn import find_executable

## Our modules
from S3 import PkgInfo
from S3.S3 import *
from S3.Config import Config
from S3.S3Uri import *
from S3 import Utils


def output(message):
	print message

def check_args_type(args, type, verbose_type):
	for arg in args:
		if S3Uri(arg).type != type:
			raise ParameterError("Expecting %s instead of '%s'" % (verbose_type, arg))

def cmd_du(args):
	s3 = S3(Config())
	if len(args) > 0:
		uri = S3Uri(args[0])
		if uri.type == "s3" and uri.has_bucket():
			subcmd_bucket_usage(s3, uri)
			return
	subcmd_bucket_usage_all(s3)

def subcmd_bucket_usage_all(s3):
	response = s3.list_all_buckets()

	buckets_size = 0
	for bucket in response["list"]:
		size = subcmd_bucket_usage(s3, S3Uri("s3://" + bucket["Name"]))
		if size != None:
			buckets_size += size
	total_size, size_coeff = formatSize(buckets_size, Config().human_readable_sizes)
	total_size_str = str(total_size) + size_coeff 
	output("".rjust(8, "-"))
	output("%s Total" % (total_size_str.ljust(8)))

def subcmd_bucket_usage(s3, uri):
	bucket = uri.bucket()
	object = uri.object()

	if object.endswith('*'):
		object = object[:-1]
	try:
		response = s3.bucket_list(bucket, prefix = object)
	except S3Error, e:
		if S3.codes.has_key(e.Code):
			error(S3.codes[e.Code] % bucket)
			return
		else:
			raise
	bucket_size = 0
	for object in response["list"]:
		size, size_coeff = formatSize(object["Size"], False)
		bucket_size += size
	total_size, size_coeff = formatSize(bucket_size, Config().human_readable_sizes)
	total_size_str = str(total_size) + size_coeff 
	output("%s %s" % (total_size_str.ljust(8), uri))
	return bucket_size

def cmd_ls(args):
	s3 = S3(Config())
	if len(args) > 0:
		uri = S3Uri(args[0])
		if uri.type == "s3" and uri.has_bucket():
			subcmd_bucket_list(s3, uri)
			return
	subcmd_buckets_list_all(s3)

def cmd_buckets_list_all_all(args):
	s3 = S3(Config())

	response = s3.list_all_buckets()

	for bucket in response["list"]:
		subcmd_bucket_list(s3, S3Uri("s3://" + bucket["Name"]))
		output("")


def subcmd_buckets_list_all(s3):
	response = s3.list_all_buckets()
	for bucket in response["list"]:
		output("%s  s3://%s" % (
			formatDateTime(bucket["CreationDate"]),
			bucket["Name"],
			))

def subcmd_bucket_list(s3, uri):
	bucket = uri.bucket()
	object = uri.object()

	output("Bucket '%s':" % bucket)
	if object.endswith('*'):
		object = object[:-1]
	try:
		response = s3.bucket_list(bucket, prefix = object)
	except S3Error, e:
		if S3.codes.has_key(e.info["Code"]):
			error(S3.codes[e.info["Code"]] % bucket)
			return
		else:
			raise
	for object in response["list"]:
		size, size_coeff = formatSize(object["Size"], Config().human_readable_sizes)
		output("%s  %s%s  %s" % (
			formatDateTime(object["LastModified"]),
			str(size).rjust(8), size_coeff.ljust(1),
			uri.compose_uri(bucket, object["Key"]),
			))

def cmd_bucket_create(args):
	uri = S3Uri(args[0])
	if not uri.type == "s3" or not uri.has_bucket() or uri.has_object():
		raise ParameterError("Expecting S3 URI with just the bucket name set instead of '%s'" % args[0])
	try:
		s3 = S3(Config())
		response = s3.bucket_create(uri.bucket(), cfg.bucket_location)
	except S3Error, e:
		if S3.codes.has_key(e.info["Code"]):
			error(S3.codes[e.info["Code"]] % uri.bucket())
			return
		else:
			raise
	output("Bucket '%s' created" % uri.bucket())

def cmd_bucket_delete(args):
	uri = S3Uri(args[0])
	if not uri.type == "s3" or not uri.has_bucket() or uri.has_object():
		raise ParameterError("Expecting S3 URI with just the bucket name set instead of '%s'" % args[0])
	try:
		s3 = S3(Config())
		response = s3.bucket_delete(uri.bucket())
	except S3Error, e:
		if S3.codes.has_key(e.info["Code"]):
			error(S3.codes[e.info["Code"]] % uri.bucket())
			return
		else:
			raise
	output("Bucket '%s' removed" % uri.bucket())

def cmd_object_put(args):
	s3 = S3(Config())

	uri_arg = args.pop()
	check_args_type(args, 'file', 'filename')

	uri = S3Uri(uri_arg)
	if uri.type != "s3":
		raise ParameterError("Expecting S3 URI instead of '%s'" % uri_arg)

	if len(args) > 1 and uri.object() != "" and not Config().force:
		error("When uploading multiple files the last argument must")
		error("be a S3 URI specifying just the bucket name")
		error("WITHOUT object name!")
		error("Alternatively use --force argument and the specified")
		error("object name will be prefixed to all stored filenames.")
		sys.exit(1)
	
	seq = 0
	total = len(args)
	for file in args:
		seq += 1
		uri_arg_final = str(uri)
		if len(args) > 1 or uri.object() == "":
			uri_arg_final += os.path.basename(file)
		
		uri_final = S3Uri(uri_arg_final)
		extra_headers = {}
		real_filename = file
		if Config().encrypt:
			exitcode, real_filename, extra_headers["x-amz-meta-s3tools-gpgenc"] = gpg_encrypt(file)
		response = s3.object_put_uri(real_filename, uri_final, extra_headers)
		output("File '%s' stored as %s (%d bytes) [%d of %d]" %
			(file, uri_final, response["size"],
			seq, total))
		if Config().acl_public:
			output("Public URL of the object is: %s" %
				(uri_final.public_url()))
		if Config().encrypt and real_filename != file:
			debug("Removing temporary encrypted file: %s" % real_filename)
			os.remove(real_filename)

def cmd_object_get(args):
	s3 = S3(Config())

	if not S3Uri(args[0]).type == 's3':
		raise ParameterError("Expecting S3 URI instead of '%s'" % args[0])

	destination_dir = None
	destination_file = None
	if len(args) > 1:
		if S3Uri(args[-1]).type == 's3':
			# all S3, use object names to local dir
			check_args_type(args, type="s3", verbose_type="S3 URI")	# May raise ParameterError
		else:
			if (len(args) > 2):
				# last must be dir, all preceding S3
				if not os.path.isdir(args[-1]):
					raise ParameterError("Last parameter must be a directory")
				destination_dir = args.pop()
				check_args_type(args, type="s3", verbose_type="S3 URI")	# May raise ParameterError
			else:
				# last must be a dir or a filename
				if os.path.isdir(args[-1]):
					destination_dir = args.pop()
				else:
					destination_file = args.pop()

	while (len(args)):
		uri_arg = args.pop(0)
		uri = S3Uri(uri_arg)

		if destination_file:
			destination = destination_file
		elif destination_dir:
			destination = destination_dir + "/" + uri.object()
		else:
			# By default the destination filename is the object name
			destination = uri.object()

		if not Config().force and os.path.exists(destination):
			raise ParameterError("File %s already exists. Use --force to overwrite it" % destination)
		response = s3.object_get_uri(uri, destination)
		if response["headers"].has_key("x-amz-meta-s3tools-gpgenc"):
			gpg_decrypt(destination, response["headers"]["x-amz-meta-s3tools-gpgenc"])
			response["size"] = os.stat(destination)[6]
		if destination != "-":
			output("Object %s saved as '%s' (%d bytes)" %
				(uri, destination, response["size"]))

def cmd_object_del(args):
	s3 = S3(Config())

	while (len(args)):
		uri_arg = args.pop(0)
		uri = S3Uri(uri_arg)
		if uri.type != "s3" or not uri.has_object():
			raise ParameterError("Expecting S3 URI instead of '%s'" % uri_arg)

		response = s3.object_delete_uri(uri)
		output("Object %s deleted" % uri)

def cmd_info(args):
	s3 = S3(Config())

	while (len(args)):
		uri_arg = args.pop(0)
		uri = S3Uri(uri_arg)
		if uri.type != "s3" or not uri.has_bucket():
			raise ParameterError("Expecting S3 URI instead of '%s'" % uri_arg)

		try:
			if uri.has_object():
				info = s3.object_info(uri)
				output("%s (object):" % uri.uri())
				output("   File size: %s" % info['headers']['content-length'])
				output("   Last mod:  %s" % info['headers']['last-modified'])
				output("   MIME type: %s" % info['headers']['content-type'])
				output("   MD5 sum:   %s" % info['headers']['etag'].strip('"'))
			else:
				info = s3.bucket_info(uri)
				output("%s (bucket):" % uri.uri())
				output("   Location:  %s" % info['bucket-location'])
			acl = s3.get_acl(uri)
			for user in acl.keys():
				output("   ACL:       %s: %s" % (user, acl[user]))
		except S3Error, e:
			if S3.codes.has_key(e.info["Code"]):
				error(S3.codes[e.info["Code"]] % uri.bucket())
				return
			else:
				raise

def cmd_sync(args):
	def _build_attr_header(src):
		attrs = {}
		st = os.stat_result(os.stat(src))
		for attr in cfg.preserve_attrs_list:
			if attr == 'uname':
				try:
					val = pwd.getpwuid(st.st_uid).pw_name
				except KeyError:
					attr = "uid"
					val = st.st_uid
					warning("%s: Owner username not known. Storing UID=%d instead." % (src, val))
			elif attr == 'gname':
				try:
					val = grp.getgrgid(st.st_gid).gr_name
				except KeyError:
					attr = "gid"
					val = st.st_gid
					warning("%s: Owner groupname not known. Storing GID=%d instead." % (src, val))
			else:
				val = getattr(st, 'st_' + attr)
			attrs[attr] = val
		result = ""
		for k in attrs: result += "%s:%s/" % (k, attrs[k])
		return { 'x-amz-meta-s3cmd-attrs' : result[:-1] }
	src = args.pop(0)
	if S3Uri(src).type != "file":
		raise ParameterError("Source must be a local path instead of: %s" % src)
	dst = args.pop(0)
	if not dst.endswith('/'):
		dst += "/"
	dst_uri = S3Uri(dst)
	if dst_uri.type != "s3":
		raise ParameterError("Destination must be a S3 URI instead of: %s" % dst)
	if (len(args)):
		raise ParameterError("Too many parameters! Expected: %s" % commands['sync']['param'])

	s3 = S3(Config())

	output("Compiling list of local files...")
	if os.path.isdir(src):
		loc_base = os.path.join(src, "")
		filelist = os.walk(src)
	else:
		loc_base = "./"
		filelist = [( '.', [], [src] )]
	loc_base_len = len(loc_base)
	loc_list = {}
	for root, dirs, files in filelist:
		## TODO: implement explicit exclude
		for f in files:
			full_name = os.path.join(root, f)
			if not os.path.isfile(full_name):
				continue
			if os.path.islink(full_name):
				## Synchronize symlinks... one day
				## for now skip over
				continue
			file = full_name[loc_base_len:]
			sr = os.stat_result(os.lstat(full_name))
			loc_list[file] = {
				'full_name' : full_name,
				'size' : sr.st_size, 
				'mtime' : sr.st_mtime,
				## TODO: Possibly more to save here...
			}
	loc_count = len(loc_list)
	
	output("Retrieving list of remote files...")
	response = s3.bucket_list(dst_uri.bucket(), prefix = dst_uri.object())

	rem_base = dst_uri.object()
	rem_base_len = len(rem_base)
	rem_list = {}
	rem_count = len(response['list'])
	for object in response['list']:
		key = object['Key'][rem_base_len:].encode('utf-8')
		rem_list[key] = { 
			'size' : int(object['Size']),
			# 'mtime' : dateS3toUnix(object['LastModified']), ## That's upload time, not our lastmod time :-(
			'md5' : object['ETag'][1:-1],
			'object_key' : object['Key'].encode('utf-8'),
		}
	output("Found %d local files, %d remote files" % (loc_count, rem_count))

	output("Verifying checksums...")
	for file in loc_list.keys():
		debug("Checking %s ..." % file)
		if rem_list.has_key(file):
			debug("%s exists in remote list" % file)
			## Check size first
			if rem_list[file]['size'] == loc_list[file]['size']:
				debug("%s same size: %s" % (file, rem_list[file]['size']))
				## ... same size, check MD5
				loc_md5 = Utils.hash_file_md5(loc_list[file]['full_name'])
				if loc_md5 == rem_list[file]['md5']:
					debug("%s md5 matches: %s" % (file, rem_list[file]['md5']))
					## Checksums are the same.
					## Remove from local-list, all that is left there will be uploaded
					debug("%s removed from local list - upload not needed" % file)
					del(loc_list[file])
				else:
					debug("! %s md5 mismatch: local=%s remote=%s" % (file, loc_md5, rem_list[file]['md5']))
			else:
				debug("! %s size mismatch: local=%s remote=%s" % (file, loc_list[file]['size'], rem_list[file]['size']))
                        
			## Remove from remote-list, all that is left there will be deleted
			debug("%s removed from remote list" % file)
			del(rem_list[file])

	output("Summary: %d local files to upload, %d remote files to delete" % (len(loc_list), len(rem_list)))
	for file in rem_list:
		uri = S3Uri("s3://" + dst_uri.bucket()+"/"+rem_list[file]['object_key'])
		if cfg.delete_removed:
			response = s3.object_delete_uri(uri)
			output("deleted '%s'" % uri)
		else:
			output("not-deleted '%s'" % uri)

	total_size = 0
	total_count = len(loc_list)
	seq = 0
	dst_base = dst_uri.uri()
	if not dst_base[-1] == "/": dst_base += "/"
	file_list = loc_list.keys()
	file_list.sort()
	for file in file_list:
		seq += 1
		src = loc_list[file]['full_name']
		uri = S3Uri(dst_base + file)
		if cfg.preserve_attrs:
			attr_header = _build_attr_header(src)
			debug(attr_header)
		response = s3.object_put_uri(src, uri, attr_header)
		output("stored '%s' as '%s' (%d bytes) [%d of %d]" % (src, uri, response["size"], seq, total_count))
		total_size += response["size"]
	output("Done. Uploaded %d bytes." % total_size)

def resolve_list(lst, args):
	retval = []
	for item in lst:
		retval.append(item % args)
	return retval

def gpg_command(command, passphrase = ""):
	p_in, p_out = os.popen4(command)
	if command.count("--passphrase-fd"):
		p_in.write(passphrase+"\n")
		p_in.flush()
	for line in p_out:
		info(line.strip())
	p_pid, p_exitcode = os.wait()
	return p_exitcode

def gpg_encrypt(filename):
	tmp_filename = Utils.mktmpfile()
	args = {
		"gpg_command" : cfg.gpg_command,
		"passphrase_fd" : "0",
		"input_file" : filename, 
		"output_file" : tmp_filename,
	}
	info("Encrypting file %(input_file)s to %(output_file)s..." % args)
	command = resolve_list(cfg.gpg_encrypt.split(" "), args)
	code = gpg_command(command, cfg.gpg_passphrase)
	return (code, tmp_filename, "gpg")

def gpg_decrypt(filename, gpgenc_header = "", in_place = True):
	tmp_filename = Utils.mktmpfile(filename)
	args = {
		"gpg_command" : cfg.gpg_command,
		"passphrase_fd" : "0",
		"input_file" : filename, 
		"output_file" : tmp_filename,
	}
	info("Decrypting file %(input_file)s to %(output_file)s..." % args)
	command = resolve_list(cfg.gpg_decrypt.split(" "), args)
	code = gpg_command(command, cfg.gpg_passphrase)
	if code == 0 and in_place:
		debug("Renaming %s to %s" % (tmp_filename, filename))
		os.unlink(filename)
		os.rename(tmp_filename, filename)
		tmp_filename = filename
	return (code, tmp_filename)

def run_configure(config_file):
	cfg = Config()
	options = [
		("access_key", "Access Key", "Access key and Secret key are your identifiers for Amazon S3"),
		("secret_key", "Secret Key"),
		("gpg_passphrase", "Encryption password", "Encryption password is used to protect your files from reading\nby unauthorized persons while in transfer to S3"),
		("gpg_command", "Path to GPG program"),
		("use_https", "Use HTTPS protocol", "When using secure HTTPS protocol all communication with Amazon S3\nservers is protected from 3rd party eavesdropping. This method is\nslower than plain HTTP and can't be used if you're behind a proxy"),
		("proxy_host", "HTTP Proxy server name", "On some networks all internet access must go through a HTTP proxy.\nTry setting it here if you can't conect to S3 directly"),
		("proxy_port", "HTTP Proxy server port"),
		]
	## Option-specfic defaults
	if getattr(cfg, "gpg_command") == "":
		setattr(cfg, "gpg_command", find_executable("gpg"))

	if getattr(cfg, "proxy_host") == "" and os.getenv("http_proxy"):
		re_match=re.match("(http://)?([^:]+):(\d+)", os.getenv("http_proxy"))
		if re_match:
			setattr(cfg, "proxy_host", re_match.groups()[1])
			setattr(cfg, "proxy_port", re_match.groups()[2])

	try:
		while 1:
			output("\nEnter new values or accept defaults in brackets with Enter.")
			output("Refer to user manual for detailed description of all options.")
			for option in options:
				prompt = option[1]
				## Option-specific handling
				if option[0] == 'proxy_host' and getattr(cfg, 'use_https') == True:
					setattr(cfg, option[0], "")
					continue
				if option[0] == 'proxy_port' and getattr(cfg, 'proxy_host') == "":
					setattr(cfg, option[0], 0)
					continue

				try:
					val = getattr(cfg, option[0])
					if type(val) is bool:
						val = val and "Yes" or "No"
					if val not in (None, ""):
						prompt += " [%s]" % val
				except AttributeError:
					pass

				if len(option) >= 3:
					output("\n%s" % option[2])

				val = raw_input(prompt + ": ")
				if val != "":
					if type(getattr(cfg, option[0])) is bool:
						# Turn 'Yes' into True, everything else into False
						val = val.lower().startswith('y')
					setattr(cfg, option[0], val)
			output("\nNew settings:")
			for option in options:
				output("  %s: %s" % (option[1], getattr(cfg, option[0])))
			val = raw_input("\nTest access with supplied credentials? [Y/n] ")
			if val.lower().startswith("y") or val == "":
				try:
					output("Please wait...")
					S3(Config()).bucket_list("", "")
					output("Success. Your access key and secret key worked fine :-)")

					output("\nNow verifying that encryption works...")
					if not getattr(cfg, "gpg_command") or not getattr(cfg, "gpg_passphrase"):
						output("Not configured. Never mind.")
					else:
						if not getattr(cfg, "gpg_command"):
							raise Exception("Path to GPG program not set")
						if not os.path.isfile(getattr(cfg, "gpg_command")):
							raise Exception("GPG program not found")
						filename = Utils.mktmpfile()
						f = open(filename, "w")
						f.write(os.sys.copyright)
						f.close()
						ret_enc = gpg_encrypt(filename)
						ret_dec = gpg_decrypt(ret_enc[1], ret_enc[2], False)
						hash = [
							Utils.hash_file_md5(filename),
							Utils.hash_file_md5(ret_enc[1]),
							Utils.hash_file_md5(ret_dec[1]),
						]
						os.unlink(filename)
						os.unlink(ret_enc[1])
						os.unlink(ret_dec[1])
						if hash[0] == hash[2] and hash[0] != hash[1]:
							output ("Success. Encryption and decryption worked fine :-)") 
						else:
							raise Exception("Encryption verification error.")

				except Exception, e:
					error("Test failed: %s" % (e))
					val = raw_input("\nRetry configuration? [Y/n] ")
					if val.lower().startswith("y") or val == "":
						continue
					

			val = raw_input("\nSave settings? [y/N] ")
			if val.lower().startswith("y"):
				break
			val = raw_input("Retry configuration? [Y/n] ")
			if val.lower().startswith("n"):
				raise EOFError()

		## Overwrite existing config file, make it user-readable only
		old_mask = os.umask(0077)
		try:
			os.remove(config_file)
		except OSError, e:
			if e.errno != errno.ENOENT:
				raise
		f = open(config_file, "w")
		os.umask(old_mask)
		cfg.dump_config(f)
		f.close()
		output("Configuration saved to '%s'" % config_file)

	except (EOFError, KeyboardInterrupt):
		output("\nConfiguration aborted. Changes were NOT saved.")
		return
	
	except IOError, e:
		error("Writing config file failed: %s: %s" % (config_file, e.strerror))
		sys.exit(1)

commands = {}
commands_list = [
	{"cmd":"mb", "label":"Make bucket", "param":"s3://BUCKET", "func":cmd_bucket_create, "argc":1},
	{"cmd":"rb", "label":"Remove bucket", "param":"s3://BUCKET", "func":cmd_bucket_delete, "argc":1},
	{"cmd":"ls", "label":"List objects or buckets", "param":"[s3://BUCKET[/PREFIX]]", "func":cmd_ls, "argc":0},
	{"cmd":"la", "label":"List all object in all buckets", "param":"", "func":cmd_buckets_list_all_all, "argc":0},
	{"cmd":"put", "label":"Put file into bucket", "param":"FILE [FILE...] s3://BUCKET[/PREFIX]", "func":cmd_object_put, "argc":2},
	{"cmd":"get", "label":"Get file from bucket", "param":"s3://BUCKET/OBJECT LOCAL_FILE", "func":cmd_object_get, "argc":1},
	{"cmd":"del", "label":"Delete file from bucket", "param":"s3://BUCKET/OBJECT", "func":cmd_object_del, "argc":1},
	#{"cmd":"mkdir", "label":"Make a virtual S3 directory", "param":"s3://BUCKET/path/to/dir", "func":cmd_mkdir, "argc":1},
	{"cmd":"sync", "label":"Synchronize a directory tree to S3", "param":"LOCAL_DIR s3://BUCKET[/PREFIX]", "func":cmd_sync, "argc":2},
	{"cmd":"du", "label":"Disk usage by buckets", "param":"[s3://BUCKET[/PREFIX]]", "func":cmd_du, "argc":0},
	{"cmd":"info", "label":"Get various information about Buckets or Objects", "param":"s3://BUCKET[/OBJECT]", "func":cmd_info, "argc":1},
	#{"cmd":"setacl", "label":"Modify Access control list for Bucket or Object", "param":"s3://BUCKET[/OBJECT]", "func":cmd_setacl, "argc":1},
	]

def format_commands(progname):
	help = "Commands:\n"
	for cmd in commands_list:
		help += "  %s\n      %s %s %s\n" % (cmd["label"], progname, cmd["cmd"], cmd["param"])
	return help

class OptionMimeType(Option):
	def check_mimetype(option, opt, value):
		if re.compile("^[a-z0-9]+/[a-z0-9+\.-]+$", re.IGNORECASE).match(value):
			return value
		raise OptionValueError("option %s: invalid MIME-Type format: %r" % (opt, value))

	TYPES = Option.TYPES + ("mimetype",)
	TYPE_CHECKER = copy(Option.TYPE_CHECKER)
	TYPE_CHECKER["mimetype"] = check_mimetype

class MyHelpFormatter(IndentedHelpFormatter):
	def format_epilog(self, epilog):
		if epilog:
			return "\n" + epilog + "\n"
		else:
			return ""

if __name__ == '__main__':
	if float("%d.%d" %(sys.version_info[0], sys.version_info[1])) < 2.4:
		sys.stderr.write("ERROR: Python 2.4 or higher required, sorry.\n")
		sys.exit(1)

	## Populate "commands" from "commands_list"
	for cmd in commands_list:
		if cmd.has_key("cmd"):
			commands[cmd["cmd"]] = cmd

	default_verbosity = Config().verbosity
	optparser = OptionParser(option_class=OptionMimeType, formatter=MyHelpFormatter())
	#optparser.disable_interspersed_args()

	optparser.set_defaults(config=os.getenv("HOME")+"/.s3cfg")
	optparser.set_defaults(verbosity = default_verbosity)

	optparser.add_option(      "--configure", dest="run_configure", action="store_true", help="Invoke interactive (re)configuration tool.")
	optparser.add_option("-c", "--config", dest="config", metavar="FILE", help="Config file name. Defaults to %default")
	optparser.add_option(      "--dump-config", dest="dump_config", action="store_true", help="Dump current configuration after parsing config files and command line options and exit.")

	optparser.add_option("-n", "--dry-run", dest="dry_run", action="store_true", help="Only show what should be uploaded or downloaded but don't actually do it. May still perform S3 requests to get bucket listings and other information though.")

	optparser.add_option("-e", "--encrypt", dest="encrypt", action="store_true", help="Encrypt files before uploading to S3.")
	optparser.add_option(      "--no-encrypt", dest="encrypt", action="store_false", help="Don't encrypt files.")
	optparser.add_option("-f", "--force", dest="force", action="store_true", help="Force overwrite and other dangerous operations.")
	optparser.add_option("-P", "--acl-public", dest="acl_public", action="store_true", help="Store objects with ACL allowing read for anyone.")
	optparser.add_option(      "--acl-private", dest="acl_public", action="store_false", help="Store objects with default ACL allowing access for you only.")
	optparser.add_option(      "--delete-removed", dest="delete_removed", action="store_true", help="Delete remote objects with no corresponding local file [sync]")
	optparser.add_option(      "--no-delete-removed", dest="delete_removed", action="store_false", help="Don't delete remote objects.")
	optparser.add_option("-p", "--preserve", dest="preserve_attrs", action="store_true", help="Preserve filesystem attributes (mode, ownership, timestamps). Default for [sync] command.")
	optparser.add_option(      "--no-preserve", dest="preserve_attrs", action="store_false", help="Don't store FS attributes")
	optparser.add_option(      "--bucket-location", dest="bucket_location", help="Datacentre to create bucket in. Either EU or US (default)")

	optparser.add_option("-m", "--mime-type", dest="default_mime_type", type="mimetype", metavar="MIME/TYPE", help="Default MIME-type to be set for objects stored.")
	optparser.add_option("-M", "--guess-mime-type", dest="guess_mime_type", action="store_true", help="Guess MIME-type of files by their extension. Falls back to default MIME-Type as specified by --mime-type option")

	optparser.add_option("-H", "--human-readable-sizes", dest="human_readable_sizes", action="store_true", help="Print sizes in human readable form.")

	optparser.add_option("-v", "--verbose", dest="verbosity", action="store_const", const=logging.INFO, help="Enable verbose output.")
	optparser.add_option("-d", "--debug", dest="verbosity", action="store_const", const=logging.DEBUG, help="Enable debug output.")
	optparser.add_option(      "--version", dest="show_version", action="store_true", help="Show s3cmd version (%s) and exit." % (PkgInfo.version))

	optparser.set_usage(optparser.usage + " COMMAND [parameters]")
	optparser.set_description('S3cmd is a tool for managing objects in '+
		'Amazon S3 storage. It allows for making and removing '+
		'"buckets" and uploading, downloading and removing '+
		'"objects" from these buckets.')
	optparser.epilog = format_commands(optparser.get_prog_name())
	optparser.epilog += ("\nSee program homepage for more information at\n%s\n" % PkgInfo.url)

	(options, args) = optparser.parse_args()

	## Some mucking with logging levels to enable 
	## debugging/verbose output for config file parser on request
	logging.basicConfig(level=options.verbosity, format='%(levelname)s: %(message)s')
	
	if options.show_version:
		output("s3cmd version %s" % PkgInfo.version)
		sys.exit(0)

	## Now finally parse the config file
	try:
		cfg = Config(options.config)
	except IOError, e:
		if options.run_configure:
			cfg = Config()
		else:
			error("%s: %s"  % (options.config, e.strerror))
			error("Configuration file not available.")
			error("Consider using --configure parameter to create one.")
			sys.exit(1)

	## And again some logging level adjustments
	## according to configfile and command line parameters
	if options.verbosity != default_verbosity:
		cfg.verbosity = options.verbosity
	logging.root.setLevel(cfg.verbosity)

	## Update Config with other parameters
	for option in cfg.option_list():
		try:
			if getattr(options, option) != None:
				debug("Updating %s -> %s" % (option, getattr(options, option)))
				cfg.update_option(option, getattr(options, option))
		except AttributeError:
			## Some Config() options are not settable from command line
			pass

	if cfg.encrypt and cfg.gpg_passphrase == "":
		error("Encryption requested but no passphrase set in config file.")
		error("Please re-run 's3cmd --configure' and supply it.")
		sys.exit(1)

	if options.dump_config:
		cfg.dump_config(sys.stdout)
		sys.exit(0)

	if options.run_configure:
		run_configure(options.config)
		sys.exit(0)

	if len(args) < 1:
		error("Missing command. Please run with --help for more information.")
		sys.exit(1)

	command = args.pop(0)
	try:
		debug("Command: " + commands[command]["cmd"])
		## We must do this lookup in extra step to 
		## avoid catching all KeyError exceptions
		## from inner functions.
		cmd_func = commands[command]["func"]
	except KeyError, e:
		error("Invalid command: %s" % e)
		sys.exit(1)

	if len(args) < commands[command]["argc"]:
		error("Not enough paramters for command '%s'" % command)
		sys.exit(1)

	try:
		cmd_func(args)
	except S3Error, e:
		error("S3 error: " + str(e))
		sys.exit(1)
	except ParameterError, e:
		error("Parameter problem: " + str(e))
		sys.exit(1)

	sys.exit(0)

